\documentclass[12pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[margin=2.54cm]{geometry}
\usepackage[dvipsnames]{xcolor}
\usepackage{array, amssymb, amsthm, enumitem, fancyhdr, float, graphicx, hyperref, hologo, mathtools, tikz, tikz-cd}
\usepackage[spanish, noabbrev]{cleveref}

\pagestyle{fancy}
\lhead{\footnotesize \leftmark}
\rhead{\footnotesize \rightmark}

\title{
	\huge
	\noindent\textbf{Fundamentos de la Ciencia de Datos}\\
	
	{\Large \textit{Práctica 1}}
	\vspace{1cm}
	
	\huge
	Grado en Ingeniería Informática\\
	Universidad de Alcalá\\
	
	\vspace{1cm}
	
	\includegraphics[scale=0.075]{img/logo}
}

\author{
	Pablo García García\\
	Abel López Martínez\\
	Álvaro Jesús Martínez Parra\\
	Raúl Moratilla Núñez
}

\date{
	\large{14 de noviembre de 2023}
}

\hypersetup{
	pdftitle={Práctica 1}, 
	pdfauthor={Pablo García García, Abel López Martínez, Álvaro Jesús Martínez Parra, Raúl Moratilla Núñez}, 
	pdfsubject={Fundamentos de la Ciencia de Datos}, 
	pdfcenterwindow, 
	pdfnewwindow=true, 
	pdfkeywords={Entrega de la PL1 de laboratorio correspondiente al Curso 2023-2024}, 
	bookmarksopen=true 
}

\begin{document}
	
<<>>=
fichero = read.csv("distancia_universitarios.csv")
fichero

len = function(list){
	count = 0
	for (element in list){
		count = count + 1
	}
	count
}

distancias = fichero$Distancia

longitud = len(distancias)
longitud

bubble = function(list, asc = TRUE){
	n = len(list)
	if(asc){
		for (i in 2:n){
			for (j in 1:(n-1)){
				if (list[j] > list[j+1]){
					temp = list[j]
					list[j] = list[j+1]
					list[j+1] = temp
				}
			}
		}
	}
	else {
		for (i in 2:n){
			for (j in 1:(n-1)){
				if (list[j] < list[j+1]){
					temp = list[j]
					list[j] = list[j+1]
					list[j+1] = temp
				}
			}
		}
	}
	list
}
distanciasordenadas = bubble(distancias, FALSE)
distanciasordenadas

rank = function(list){
	ordered_list = bubble(list)
	ordered_list[len(ordered_list)] - ordered_list[1]
}

rango = rank(distanciasordenadas)
rango

absolute_freq = function(list){
	ordered_list = bubble(list)
	n = len(ordered_list)
	elements = vector()
	frequencies = vector()
	i = 1
	while (i <= n){
		actual_element = ordered_list[i]
		elements = append(elements, actual_element)
		actual_freq = 0
		j = i
		while(j <= n & actual_element == ordered_list[j]){
			actual_freq = actual_freq + 1
			j = j+1
		}
		frequencies = append(frequencies, actual_freq)
		i = j
	}
	rbind(elements, frequencies)
}

	

@

PARTE 2

<<>>=

for (i in 2:kMax) { #itera dimensiones k

for (j in 1:len(split)) { #itera elementos de dim k

for (k in 1:(i-1)) { #itera posibilidades que haya en el lado izquierdo; -1 es para quitar los conjuntos vacios; numero de elementos que hay a la izq de la implic

@

<<>>=


len = function(list){
count = 0
for (element in list){
count = count + 1
}
count
}

union = function(c1, c2){
if (len(c1) == 0){
c2
}
else if (is.element(c1[1], c2)){
union(c1[-1], c2)
}
else{
union(c1[-1], append(c2, c1[1]))
}
}

intersect = function(c1, c2){
if (len(c1) == 0){
c()
}
else if (is.element(c1[1], c2)){
append(intersect(c1[-1], c2), c1[1])
}
else{
intersect(c1[-1], c2)
}
}

dif = function(c1, c2) {
res = c()
for (element in c1) {
if (!(element %in% c2)) {
res = append(res, element)
}
}
res
}

tabla <- matrix(c(1,1,0,1,1, 1,1,1,1,0, 1,1,0,1,0, 1,0,1,1,0, 1,1,0,0,0, 0,0,0,1,0),6,5,byrow=TRUE,dimnames=list(c("suceso1","suceso2","suceso3","suceso4","suceso5","suceso6"),c("P","A","C","L","N")))

count_appearance = function(table, elements){
count = 0
for (i in 1:len(table[,1])){
acum = 1
for (element in elements){
acum = (table[i,element]) & acum
}
count = count + acum
}
count
}

support = function(table, elements) {
count_appearance(table, elements) / len(table[,1])
}

support_clasif = function(table, ocurrences, s){
valid_ocurrences = c()
for (ocurrence in ocurrences){
support_oc = support(table, ocurrence)
if (support_oc >= s){
valid_ocurrences = append(valid_ocurrences, ocurrence)
}
}
valid_ocurrences	
}

create_comb = function(table, clasif, s) {
lista = c()
dim = 2
next_dim = TRUE
while (dim <= len(clasif) & next_dim == TRUE) {
next_dim = FALSE
comb = unlist(lapply(dim, function(m) {combn(clasif, m=m, simplify=TRUE)}), recursive=FALSE)

for (j in seq(1, len(comb), by=dim)) {
add = c()
for (k in j:(j+dim-1)) {
add = append(add, comb[k])
}
if (support(table, add) >= s) {
next_dim = TRUE
lista = append(lista, list(add))
}
}
dim = dim+1
}
lista
}

confidence = function(table, left, right) {
count_appearance(table, union(left, right)) / count_appearance(table, left)
}

get_asotiations = function(table, comb, c) {
kMax = len(comb[len(comb)][[1]])
listLeft = list()
listRight = list()

for (i in 2:kMax) {

split = Filter(function(x) length(x)==i, comb)

for (j in 1:len(split)) {

for (k in 1:(i-1)) {

leftSides = lapply(k, function(m) {combn(split[j][[1]], m=m, simplify=TRUE)})

df = do.call(rbind.data.frame, leftSides)

for (n in 1:len(df[1,])) {

all = split[j][[1]]

left = df[,n]

right = dif(split[j][[1]], df[,n])

if (confidence(table, left, right) >= c) {

listLeft = append(listLeft , list(left))
listRight = append(listRight , list(right))

} else {
print("Mejora posible")
}
}
}
}
}
asoc = data.frame(left = I(listLeft), right = I(listRight))
asoc
}

apriori = function(table, s, c) {
soporte_clasif = support_clasif(tabla, c(c("P"), c("A") ,c("L"), c("C"), c("N")), s)

combinaciones = create_comb(tabla, soporte_clasif, s)

conf = get_asotiations(tabla, combinaciones, c)

print(conf)

}

apriori(tabla, 0.5, 0.8)


@


40 de soporte y 90 de confianza
\end{document}          
